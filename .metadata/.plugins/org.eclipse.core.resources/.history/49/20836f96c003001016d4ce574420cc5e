package com.care.boot.game;

import org.springframework.messaging.handler.annotation.MessageMapping;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;
import com.care.boot.gamedto.GameDTO;
import com.care.boot.gamedto.PlayerStatsDTO;
import com.care.boot.gamedto.GameRequest;
import java.time.LocalDateTime;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;

@Controller
@RequestMapping("/game")
public class GameController {
    private final SimpMessagingTemplate messagingTemplate;
    private final GameService gameService;
    private final ConcurrentLinkedQueue<String> waitingPlayers = new ConcurrentLinkedQueue<>();
    private final ConcurrentHashMap<String, String> gameMoves = new ConcurrentHashMap<>();
    private final ConcurrentHashMap<String, String> opponentMap = new ConcurrentHashMap<>();

    public GameController(SimpMessagingTemplate messagingTemplate, GameService gameService) {
        this.messagingTemplate = messagingTemplate;
        this.gameService = gameService;
    }

    // ğŸ”¹ WebSocketì„ ì´ìš©í•œ ê²Œì„ í”Œë ˆì´
    @MessageMapping("/play")
    public void play(GameRequest request) {
        String playerId = request.getPlayerId();
        String move = request.getMove();
        String mode = (request.getMode() == null || request.getMode().isEmpty()) ? "server" : request.getMode(); // âœ… ê¸°ë³¸ê°’ ì„¤ì •

        System.out.println("ğŸ® í”Œë ˆì´ ìš”ì²­: " + playerId + " | ì„ íƒ: " + move + " | ëª¨ë“œ: " + mode);

        if ("server".equals(mode)) {
            processServerMode(playerId, move);
        } else {
            processPlayerMode(playerId, move);
        }
    }

    // ğŸ”¹ íŠ¹ì • í”Œë ˆì´ì–´ ì „ì  ì¡°íšŒ (REST API)
    @GetMapping("/stats")
    @ResponseBody
    public PlayerStatsDTO getPlayerStats(@RequestParam String playerId) {
        return gameService.getPlayerStats(playerId);
    }

    // ğŸ”¹ ì „ì²´ ë­í‚¹ ì¡°íšŒ (REST API)
    @GetMapping("/ranking")
    @ResponseBody
    public List<PlayerStatsDTO> getRanking() {
        return gameService.getRanking();
    }

    // ğŸ”¹ íŠ¹ì • í”Œë ˆì´ì–´ì˜ ê²Œì„ ê¸°ë¡ ì¡°íšŒ (REST API)
    @GetMapping("/history")
    @ResponseBody
    public List<GameDTO> getGameHistory(@RequestParam String playerId) {
        return gameService.getGameHistory(playerId);
    }

    // âœ… ì„œë²„ì™€ í”Œë ˆì´í•˜ëŠ” ëª¨ë“œ (ì»´í“¨í„°ì™€ ëŒ€ê²°)
    private void processServerMode(String playerId, String move) {
        String serverMove = getRandomMove();
        String result = determineWinner(move, serverMove);

        // âœ… í”Œë ˆì´ì–´ì˜ ì…ë ¥ê°’ì´ ì˜¬ë°”ë¥´ê²Œ ì „ë‹¬ë˜ëŠ”ì§€ í™•ì¸
        System.out.println("ğŸ“¢ ì„œë²„ ëª¨ë“œ ì§„í–‰: playerId=" + playerId + ", playerMove=" + move + ", serverMove=" + serverMove + ", result=" + result);

        // âœ… `GameDTO` ê°ì²´ ìƒì„± ì‹œ ê°’ì´ ì˜¬ë°”ë¥´ê²Œ ë“¤ì–´ê°€ëŠ”ì§€ í™•ì¸
        GameDTO gameDTO = new GameDTO(0, playerId, "server", move, serverMove, result, LocalDateTime.now());
        System.out.println("âœ… GameDTO ìƒì„±ë¨: " + gameDTO);

        // âœ… ë°ì´í„° ì €ì¥ í›„ ë‹¤ì‹œ í™•ì¸
        gameService.saveGameResult(gameDTO);

        // âœ… í´ë¼ì´ì–¸íŠ¸ë¡œ JSON ë³€í™˜ í›„ ì „ì†¡
        messagingTemplate.convertAndSend("/topic/result/" + playerId, gameDTO);
    }



    // âœ… í”Œë ˆì´ì–´ ê°„ ë§¤ì¹­ ê¸°ëŠ¥ ì¶”ê°€
    private void processPlayerMode(String playerId, String move) {
        if (!opponentMap.containsKey(playerId)) {
            // ë§¤ì¹­ ëŒ€ê¸°ì—´ì— í”Œë ˆì´ì–´ ì¶”ê°€
            waitingPlayers.add(playerId);
            messagingTemplate.convertAndSend("/topic/match", "ğŸ• " + playerId + " ë§¤ì¹­ ëŒ€ê¸° ì¤‘...");
        } else {
            // ìƒëŒ€ë°©ì´ ë§¤ì¹­ ì™„ë£Œë¨
            String opponentId = opponentMap.get(playerId);
            gameMoves.put(playerId, move);

            if (gameMoves.containsKey(opponentId)) {
                // ë‘ í”Œë ˆì´ì–´ê°€ ëª¨ë‘ ì„ íƒì„ ì™„ë£Œí•¨ â†’ ê²°ê³¼ ê³„ì‚°
                String opponentMove = gameMoves.remove(opponentId);
                String result = determineWinner(move, opponentMove);
                String opponentResult = determineWinner(opponentMove, move);

                GameDTO playerGame = new GameDTO(0, playerId, opponentId, move, opponentMove, result, LocalDateTime.now());
                GameDTO opponentGame = new GameDTO(0, opponentId, playerId, opponentMove, move, opponentResult, LocalDateTime.now());

                gameService.saveGameResult(playerGame);
                gameService.saveGameResult(opponentGame);

                // í´ë¼ì´ì–¸íŠ¸ë¡œ ê²°ê³¼ ì „ì†¡
                messagingTemplate.convertAndSend("/topic/result/" + playerId, playerGame);
                messagingTemplate.convertAndSend("/topic/result/" + opponentId, opponentGame);

                // ë§¤ì¹­ ì •ë³´ ì‚­ì œ
                opponentMap.remove(playerId);
                opponentMap.remove(opponentId);
            }
        }
    }

    // âœ… ëœë¤ ê°€ìœ„ë°”ìœ„ë³´ ì„ íƒ
    private String getRandomMove() {
        String[] moves = {"ê°€ìœ„", "ë°”ìœ„", "ë³´"};
        return moves[(int) (Math.random() * 3)];
    }

    // âœ… ìŠ¹íŒ¨ ê²°ì • ë¡œì§
    private String determineWinner(String move1, String move2) {
        if (move1.equals(move2)) return "ë¬´ìŠ¹ë¶€";
        if ((move1.equals("ê°€ìœ„") && move2.equals("ë³´")) ||
            (move1.equals("ë°”ìœ„") && move2.equals("ê°€ìœ„")) ||
            (move1.equals("ë³´") && move2.equals("ë°”ìœ„"))) {
            return "ìŠ¹ë¦¬";
        }
        return "íŒ¨ë°°";
    }
}
